{"title":"跨域资源共享","slug":"日常学习/技术相关/HTTP协议与网络编程/4. 跨域资源共享","date":"2020-08-11T11:18:01.000Z","updated":"2022-02-21T13:24:30.860Z","comments":true,"path":"api/articles/日常学习/技术相关/HTTP协议与网络编程/4. 跨域资源共享.json","excerpt":null,"covers":null,"content":"<h2 id=\"跨域资源共享是什么\"><a class=\"markdownIt-Anchor\" href=\"#跨域资源共享是什么\"></a> 跨域资源共享是什么</h2>\n<p>CORS全称为Cross-Origin Resource Sharing，被译为跨域资源共享，新増了一组HTTP首部字段，允许服务器声明哪些源站有权限访问哪些资源。</p>\n<p>跨域资源共享标规范要求，对那些可能对服务器数据产生副作用的HTTP请求方法（特别是GET以外的HTTP请求，或者搭配某些MIME类型的POST请求），浏览器必须首先使用OPTIONS方法发起一个预检请求，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的HTTP请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证。</p>\n<p>跨域资源共享机制的工作原理主要应用于三个场景</p>\n<ol>\n<li>简单请求</li>\n<li>预检请求</li>\n<li>认证请求</li>\n</ol>\n<h2 id=\"简单请求\"><a class=\"markdownIt-Anchor\" href=\"#简单请求\"></a> 简单请求</h2>\n<ol>\n<li>请求方法为：GET、HEAD、POST其中一个</li>\n<li>不得人为设置下列集合之外的其他首部字段：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code></li>\n<li><code>Content-Type</code>的值仅限以下三者之一\n<ul>\n<li><code>text/plain</code></li>\n<li><code>multipart/form-data</code></li>\n<li><code>application/x-www-form-urlencoded</code></li>\n</ul>\n</li>\n</ol>\n<p>值得注意的是，这些跨域请求与浏览器发出的其他跨域请求并无二致。如果服务器未返回正确的响应首部，则请求方不会收到任何数据。因此，那些不允许跨域请求的网站无需为这一新的HTTP访问控制特性担心。</p>\n<h2 id=\"预检请求\"><a class=\"markdownIt-Anchor\" href=\"#预检请求\"></a> 预检请求</h2>\n<h3 id=\"预检请求是什么\"><a class=\"markdownIt-Anchor\" href=\"#预检请求是什么\"></a> 预检请求是什么</h3>\n<ol>\n<li>请求方法为：PUT、DELETE、CONNECT、OPTIONS、TRACE、PATH</li>\n<li>不得人为设置下列集合之外的其他首部字段：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code></li>\n<li><code>Content-Type</code>的值仅限以下三者之一\n<ul>\n<li><code>text/plain</code></li>\n<li><code>multipart/form-data</code></li>\n<li><code>application/x-www-form-urlencoded</code></li>\n</ul>\n</li>\n</ol>\n<p>预检请求要求必须首先使用OPTONS方法发起一个预检请求到服务器，以获取服务器是否允许该实际请求。</p>\n<p>预检请求可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>\n<h2 id=\"认证请求\"><a class=\"markdownIt-Anchor\" href=\"#认证请求\"></a> 认证请求</h2>\n<p>XMLHttpRequest与 CORS 的一个有趣的特性是，可以基于HTTP cookies和 HTTP 认证信息发送身份凭证。一般而言，对于跨域 XMLHttpRequest 请求，浏览器<strong>不会</strong>发送身份凭证信息。如果要发送凭证信息，需要设置 <code>XMLHttpRequest</code>的某个特殊标志位。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">xmlHttpRequest<span class=\"token punctuation\">.</span>withCredentials <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><code>withCredentials</code> 标志设置为 <code>true</code>，从而向服务器发送 Cookies。因为这是一个简单 GET 请求，所以浏览器不会对其发起“预检请求”。但是，如果服务器端的响应中未携带 <code>Access-Control-Allow-Credentials: true</code> ，浏览器将不会把响应内容返回给请求的发送者。</p>\n","more":"<h2 id=\"跨域资源共享是什么\"><a class=\"markdownIt-Anchor\" href=\"#跨域资源共享是什么\"></a> 跨域资源共享是什么</h2>\n<p>CORS全称为Cross-Origin Resource Sharing，被译为跨域资源共享，新増了一组HTTP首部字段，允许服务器声明哪些源站有权限访问哪些资源。</p>\n<p>跨域资源共享标规范要求，对那些可能对服务器数据产生副作用的HTTP请求方法（特别是GET以外的HTTP请求，或者搭配某些MIME类型的POST请求），浏览器必须首先使用OPTIONS方法发起一个预检请求，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的HTTP请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证。</p>\n<p>跨域资源共享机制的工作原理主要应用于三个场景</p>\n<ol>\n<li>简单请求</li>\n<li>预检请求</li>\n<li>认证请求</li>\n</ol>\n<h2 id=\"简单请求\"><a class=\"markdownIt-Anchor\" href=\"#简单请求\"></a> 简单请求</h2>\n<ol>\n<li>请求方法为：GET、HEAD、POST其中一个</li>\n<li>不得人为设置下列集合之外的其他首部字段：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code></li>\n<li><code>Content-Type</code>的值仅限以下三者之一\n<ul>\n<li><code>text/plain</code></li>\n<li><code>multipart/form-data</code></li>\n<li><code>application/x-www-form-urlencoded</code></li>\n</ul>\n</li>\n</ol>\n<p>值得注意的是，这些跨域请求与浏览器发出的其他跨域请求并无二致。如果服务器未返回正确的响应首部，则请求方不会收到任何数据。因此，那些不允许跨域请求的网站无需为这一新的HTTP访问控制特性担心。</p>\n<h2 id=\"预检请求\"><a class=\"markdownIt-Anchor\" href=\"#预检请求\"></a> 预检请求</h2>\n<h3 id=\"预检请求是什么\"><a class=\"markdownIt-Anchor\" href=\"#预检请求是什么\"></a> 预检请求是什么</h3>\n<ol>\n<li>请求方法为：PUT、DELETE、CONNECT、OPTIONS、TRACE、PATH</li>\n<li>不得人为设置下列集合之外的其他首部字段：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code></li>\n<li><code>Content-Type</code>的值仅限以下三者之一\n<ul>\n<li><code>text/plain</code></li>\n<li><code>multipart/form-data</code></li>\n<li><code>application/x-www-form-urlencoded</code></li>\n</ul>\n</li>\n</ol>\n<p>预检请求要求必须首先使用OPTONS方法发起一个预检请求到服务器，以获取服务器是否允许该实际请求。</p>\n<p>预检请求可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>\n<h2 id=\"认证请求\"><a class=\"markdownIt-Anchor\" href=\"#认证请求\"></a> 认证请求</h2>\n<p>XMLHttpRequest与 CORS 的一个有趣的特性是，可以基于HTTP cookies和 HTTP 认证信息发送身份凭证。一般而言，对于跨域 XMLHttpRequest 请求，浏览器<strong>不会</strong>发送身份凭证信息。如果要发送凭证信息，需要设置 <code>XMLHttpRequest</code>的某个特殊标志位。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">xmlHttpRequest<span class=\"token punctuation\">.</span>withCredentials <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><code>withCredentials</code> 标志设置为 <code>true</code>，从而向服务器发送 Cookies。因为这是一个简单 GET 请求，所以浏览器不会对其发起“预检请求”。但是，如果服务器端的响应中未携带 <code>Access-Control-Allow-Credentials: true</code> ，浏览器将不会把响应内容返回给请求的发送者。</p>\n","categories":[{"name":"HTTP网络协议","path":"api/categories/HTTP网络协议.json"}],"tags":[{"name":"HTTP","path":"api/tags/HTTP.json"},{"name":"网络编程","path":"api/tags/网络编程.json"}]}